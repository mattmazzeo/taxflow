import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { z } from "zod";
import archiver from "archiver";
import { format } from "date-fns";

const RequestSchema = z.object({
  taxYearId: z.string().uuid(),
});

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();

    // Check auth
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check plan (export requires Pro)
    const { data: profile } = await supabase
      .from("profiles")
      .select("plan")
      .eq("user_id", user.id)
      .single();

    if (profile?.plan !== "pro") {
      return NextResponse.json(
        { error: "Export package requires Pro plan" },
        { status: 403 }
      );
    }

    // Validate request body
    const body = await request.json();
    const { taxYearId } = RequestSchema.parse(body);

    // Get tax year info
    const { data: taxYear, error: taxYearError } = await supabase
      .from("tax_years")
      .select("*")
      .eq("id", taxYearId)
      .single();

    if (taxYearError || !taxYear) {
      return NextResponse.json({ error: "Tax year not found" }, { status: 404 });
    }

    // Get all documents
    const { data: documents } = await supabase
      .from("documents")
      .select("*")
      .eq("tax_year_id", taxYearId);

    if (!documents || documents.length === 0) {
      return NextResponse.json(
        { error: "No documents found for this tax year" },
        { status: 404 }
      );
    }

    // Get all entities
    const documentIds = documents.map((d) => d.id);
    const { data: entities } = await supabase
      .from("document_entities")
      .select("*")
      .in("document_id", documentIds);

    // Create ZIP archive in memory
    const archive = archiver("zip", {
      zlib: { level: 9 }, // Compression level
    });

    const chunks: Buffer[] = [];

    archive.on("data", (chunk) => {
      chunks.push(chunk);
    });

    // Generate CSV of entities
    const csvHeader = "Document,Entity Type,Field,Value,Confidence\n";
    const csvRows = (entities || [])
      .map((entity) => {
        const doc = documents.find((d) => d.id === entity.document_id);
        const docName = doc?.filename || "Unknown";
        return `"${docName}","${entity.entity_type}","${entity.key}","${entity.value || ""}","${entity.confidence || ""}"`
      })
      .join("\n");

    const csvContent = csvHeader + csvRows;
    archive.append(csvContent, { name: "entities.csv" });

    // Generate JSON summary
    const summary = {
      taxYear: taxYear.year,
      exportDate: new Date().toISOString(),
      totalDocuments: documents.length,
      parsedDocuments: documents.filter((d) => d.parsed).length,
      totalEntities: entities?.length || 0,
      entityTypes: Array.from(
        new Set((entities || []).map((e) => e.entity_type))
      ),
      documents: documents.map((doc) => ({
        filename: doc.filename,
        source: doc.source,
        parsed: doc.parsed,
        uploadDate: doc.created_at,
        entityCount: entities?.filter((e) => e.document_id === doc.id).length || 0,
      })),
    };

    archive.append(JSON.stringify(summary, null, 2), { name: "summary.json" });

    // Add original document files
    for (const doc of documents) {
      if (doc.storage_path) {
        try {
          const { data: fileData } = await supabase.storage
            .from("docs")
            .download(doc.storage_path);

          if (fileData) {
            const arrayBuffer = await fileData.arrayBuffer();
            const buffer = Buffer.from(arrayBuffer);
            archive.append(buffer, { name: `documents/${doc.filename}` });
          }
        } catch (error) {
          console.error(`Failed to download ${doc.filename}:`, error);
          // Continue with other files
        }
      }
    }

    // Add a README
    const readme = `TaxFlow Export Package
Tax Year: ${taxYear.year}
Export Date: ${format(new Date(), "PPP")}
Total Documents: ${documents.length}

Files included:
- entities.csv: All extracted data fields in CSV format
- summary.json: Overview of documents and entities
- documents/: Folder containing all original uploaded documents

This package contains all your tax documents and extracted information for ${taxYear.year}.
Share this with your CPA or tax preparer for easy filing.

Generated by TaxFlow - https://taxflow.app
`;

    archive.append(readme, { name: "README.txt" });

    // Finalize archive
    await archive.finalize();

    // Wait for archive to complete
    await new Promise<void>((resolve, reject) => {
      archive.on("end", resolve);
      archive.on("error", reject);
    });

    // Combine chunks into single buffer
    const zipBuffer = Buffer.concat(chunks);

    // Upload ZIP to storage (temporary, expires in 1 hour)
    const zipFilename = `exports/${user.id}/${taxYear.year}_${Date.now()}.zip`;

    const { error: uploadError } = await supabase.storage
      .from("docs")
      .upload(zipFilename, zipBuffer, {
        contentType: "application/zip",
        upsert: true,
      });

    if (uploadError) {
      console.error("Upload error:", uploadError);
      return NextResponse.json(
        { error: "Failed to upload export package" },
        { status: 500 }
      );
    }

    // Create signed URL (expires in 1 hour)
    const { data: signedUrl } = await supabase.storage
      .from("docs")
      .createSignedUrl(zipFilename, 3600); // 1 hour

    if (!signedUrl) {
      return NextResponse.json(
        { error: "Failed to create download URL" },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      downloadUrl: signedUrl.signedUrl,
      expiresIn: 3600,
      filename: `TaxFlow_${taxYear.year}_Export_${format(new Date(), "yyyy-MM-dd")}.zip`,
    });
  } catch (error) {
    console.error("Export error:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid request data", details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

